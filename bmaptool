#!/usr/bin/env python
#
# Copyright (c) 2012 Intel, Inc.
# License: GPLv2
# Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

# Note! We use the below docstring for the program help text as well.
""" This is a tool to generate block map files (bmap) and to copy files using
bmap. Generally speaking, these tools are about writing large image files
quickly.

The bmap file is an XML file which contains a list of mapped blocks of the
image. Mapped blocks are the blocks which have disk sectors associated with
them, as opposed to holes, which are blocks with no associated disk sectors. In
other words, the image is considered to be a sparse file, and bmap basically
contains a list of mapped blocks of this sparse file. The bmap additionally
contains some useful information like block size (usually 4KiB), image size,
mapped blocks count, etc.

The bmap is used for copying the image to a block device or to a regular file.
The idea is that we copy quickly with bmap because we copy only mapped blocks
and ignore the holes, because they are useless. And if the image is generated
properly (starting with a huge hole and writing all the data), it usually
contains only little mapped blocks, comparing to the overall image size. And
such an image compresses very well (because holes are read as all zeroes), so
it is beneficial to distribute them as compressed files along with the bmap.

Here is an example. Suppose you have a 4GiB image which contains only 100MiB of
user data and you need to flash it to a slow USB stick. With bmap you end up
copying only a little bit more than 100MiB of data from the image to the USB
stick (namely, you write only mapped blocks). This is a lot faster than copying
all 4GiB of data. We say that it is a bit more than 100MiB because things like
file-system meta-data (inode tables, superblocks, etc), partition table, etc
also contribute to the mapped blocks and are also copied. """

VERSION = "1.0"

import argparse
import sys
import os
import stat
import time
import logging
from bmaptools import BmapCreate, BmapCopy, BmapHelpers

def copy_command(args, log):
    """ Copy an image to a block device or a regular file using bmap. """

    # Try to open the destination file. If it does not exist, a new regular
    # file will be created. If it exists and it is a regular file - it'll be
    # truncated. If this is a block device, it'll just be opened.
    try:
        dest_file = open(args.dest, 'wb+')
    except IOError as err:
        log.error("cannot open destination file '%s': %s" \
                  % (args.dest, err))
        raise SystemExit(1)

    dest_file.close()

    # Check whether the destination file is a block device
    try:
        is_block_device = stat.S_ISBLK(os.stat(args.dest).st_mode)
    except OSError as err:
        log.error("cannot access destination file '%s': %s" \
                   % (args.bdev, err.strerror))
        raise SystemExit(1)

    try:
        if is_block_device:
            # For block devices, use the specialized class
            destination_type = "block device"
            writer = BmapCopy.BmapBdevCopy(args.image, args.dest, args.bmap)
        else:
            destination_type = "file"
            writer = BmapCopy.BmapCopy(args.image, args.dest, args.bmap)
    except BmapCopy.Error as err:
        log.error(str(err))
        raise SystemExit(1)

    # Print the progress indicator while copying
    writer.set_progress_indicator(sys.stderr, "bmaptool: info: %d%% copied")

    start_time = time.time()
    if not args.bmap:
        log.warning("no bmap, copying will be slow! (use --bmap option)")
        log.info("falling-back to copying entire image to '%s'" % args.dest)
    else:
        log.info("block map format version %s" % writer.bmap_version)
        log.info("%d blocks of size %d (%s), mapped %d blocks (%s or %.1f%%)" \
                 % (writer.blocks_cnt, writer.block_size,
                    writer.image_size_human, writer.mapped_cnt,
                    writer.mapped_size_human, writer.mapped_percent))
        log.info("copying the image to %s '%s' using bmap file '%s'" \
                 % (destination_type, args.dest, args.bmap))

    try:
        try:
            writer.copy(False, not args.no_verify)
        except BmapCopy.Error as err:
            log.error(str(err))
            raise SystemExit(1)

        # Synchronize the block device
        log.info("synchronizing '%s'" % args.dest)
        try:
            writer.sync()
        except BmapCopy.Error as err:
            log.error(str(err))
            raise SystemExit(1)
    except KeyboardInterrupt:
        log.error("the program is interrupted, exiting")
        raise SystemExit(1)

    copying_time = time.time() - start_time
    copying_speed = writer.mapped_size / copying_time
    log.info("copying time: %s, copying speed %s/sec" \
             % (BmapHelpers.human_time(copying_time), \
                BmapHelpers.human_size(copying_speed)))

def create_command(args, log):
    """ Generate block map (AKA bmap) for an image. The idea is that while
    images files may generally be very large (e.g., 4GiB), they may
    nevertheless contain only little real data, e.g., 512MiB. This data are
    files, directories, file-system meta-data, partition table, etc. When
    copying the image to the target device, you do not have to copy all the
    4GiB of data, you can copy only 512MiB of it, which is 4 times less, so
    copying should presumably be 4 times faster.

    The block map file is an XML file which contains a list of blocks which
    have to be copied to the target device. The other blocks are not used and
    there is no need to copy them. The XML file also contains some additional
    information like block size, image size, count of mapped blocks, etc. There
    are also many commentaries, so it is human-readable.

    The image has to be a sparse file. Generally, this means that when you
    generate this image file, you should start with a huge sparse file which
    contains a single hole spanning the entire file. Then you should partition
    it, write all the data (probably by means of loop-back mounting the image
    or parts of it), etc. The end result should be a sparse file where mapped
    areas represent useful parts of the image and holes represent useless parts
    of the image, which do not have to be copied when copying the image to the
    target device. """

    # Create and setup the output stream
    if args.output:
        try:
            output = open(args.output, "w+")
        except IOError as err:
            log.error("cannot open the output file '%s': %s" \
                      % (args.output, err))
            raise SystemExit(1)
    else:
        output = sys.stdout

    try:
        creator = BmapCreate.BmapCreate(args.image, output)
        creator.generate(not args.no_checksum)
    except BmapCreate.Error as err:
        log.error(str(err))
        raise SystemExit(1)

    if creator.mapped_cnt == creator.blocks_cnt:
        log.warning("all %s are mapped, no holes in '%s'" \
                    % (creator.image_size_human, args.image))
        log.warning("was the image handled incorrectly and holes " \
                    "were expanded?")

def parse_arguments():
    """ A helper function which parses the input arguments. """

    parser = argparse.ArgumentParser(description = __doc__, prog = 'bmaptool')

    # The --version option
    parser.add_argument("--version", action = "version", \
                        version = "%(prog)s " + "%s" % VERSION)

    # The --quiet option
    text = "be quiet"
    parser.add_argument("-q", "--quiet", action = "store_true", help = text)

    subparsers = parser.add_subparsers(title = "subcommands")

    #
    # Create the parser for the "create" command
    #
    text = "generate bmap for an image file (which should be a sparse file)"
    parser_create = subparsers.add_parser("create", help = text)
    parser_create.set_defaults(func=create_command)

    # Mandatory command-line argument - image file
    text = "the image to generate bmap for"
    parser_create.add_argument("image", help = text)

    # The --output option
    text = "the output file name (otherwise stdout is used)"
    parser_create.add_argument("-o", "--output", help = text)

    # The --no-checksum option
    text = "do not generate the checksum for block ranges in the bmap"
    parser_create.add_argument("--no-checksum", action="store_true",
                               help = text)

    #
    # Create the parser for the "copy" command
    #
    text = "write an image to a block device using bmap"
    parser_copy = subparsers.add_parser("copy", help = text)
    parser_copy.set_defaults(func=copy_command)

    # The first positional argument - image file
    text = "the image file to copy. Supported formats: uncompressed, " + \
           ", ".join(BmapCopy.SUPPORTED_IMAGE_FORMATS)
    parser_copy.add_argument("image", help = text)

    # The second positional argument - block device node
    text = "the destination file or device node to copy the image to"
    parser_copy.add_argument("dest", help = text)

    # The --bmap option
    text = "the block map file for the image"
    parser_copy.add_argument("--bmap", help = text)

    # The --no-verify option
    text = "do not verify the data checksum while writing"
    parser_copy.add_argument("--no-verify", action="store_true", help = text)

    return parser.parse_args()

def setup_logger(loglevel):
    """ A helper function which sets up and configures the logger. The log
    level is initialized to 'loglevel'. Returns the logger object. """

    # Esc-sequences for coloured output
    esc_red = '\033[91m'
    esc_yellow = '\033[93m'
    esc_end = '\033[0m'

    # Change log level names to something less nicer than the default
    # all-capital 'INFO' etc.
    logging.addLevelName(logging.ERROR, esc_red + "ERROR" + esc_end)
    logging.addLevelName(logging.WARNING, esc_yellow + "WARNING" + esc_end)
    logging.addLevelName(logging.DEBUG, "debug")
    logging.addLevelName(logging.INFO, "info")

    log = logging.getLogger('bmap-logger')
    log.setLevel(loglevel)
    formatter = logging.Formatter("bmaptool: %(levelname)s: %(message)s")
    where = logging.StreamHandler(sys.stderr)
    where.setFormatter(formatter)
    log.addHandler(where)

    return log

def main():
    """ Script entry point. """

    args = parse_arguments()

    if args.quiet:
        loglevel = logging.ERROR
    else:
        loglevel = logging.INFO

    args.func(args, setup_logger(loglevel))

if __name__ == "__main__":
    sys.exit(main())
