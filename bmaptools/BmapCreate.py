""" This module implements the block map (bmap) creation functionality and
provides the corresponding API in form of the 'BmapCreate' class.

The idea is that while images files may generally be very large (e.g., 4GiB),
they may nevertheless contain only little real data, e.g., 512MiB. This data
are files, directories, file-system meta-data, partition table, etc. When
copying the image to the target device, you do not have to copy all the 4GiB of
data, you can copy only 512MiB of it, which is 4 times less, so copying should
presumably be 4 times faster.

The block map file is an XML file which contains a list of blocks which have to
be copied to the target device. The other blocks are not used and there is no
need to copy them. The XML file also contains some additional information like
block size, image size, count of mapped blocks, etc. There are also many
commentaries, so it is human-readable.

The image has to be a sparse file. Generally, this means that when you generate
this image file, you should start with a huge sparse file which contains a
single hole spanning the entire file. Then you should partition it, write all
the data (probably by means of loop-back mounting the image or parts of it),
etc. The end result should be a sparse file where mapped areas represent useful
parts of the image and holes represent useless parts of the image, which do not
have to be copied when copying the image to the target device.

This module uses the FIBMAP ioctl to detect holes. """

# Disable the following pylint recommendations:
#   *  Too many instance attributes - R0902
#   *  Too few public methods - R0903
# pylint: disable=R0902,R0903

import os
import hashlib
from fcntl import ioctl
import struct
from itertools import groupby
from bmaptools.BmapHelpers import human_size, get_block_size
import array

# The bmap format version we generate
SUPPORTED_BMAP_VERSION = "1.2"

_BMAP_START_TEMPLATE = \
"""<?xml version="1.0" ?>
<!-- This file contains the block map for an image file, which is basically
     a list of useful (mapped) block numbers in the image file. In other words,
     it lists only those blocks which contain data (boot sector, partition
     table, file-system metadata, files, directories, extents, etc). These
     blocks have to be copied to the target device. The other blocks do not
     contain any useful data and do not have to be copied to the target
     device.

     The block map an optimization which allows to copy or flash the image to
     the image quicker than copying of flashing the entire image. This is
     because with bmap less data is copied: <MappedBlocksCount> blocks instead
     of <BlocksCount> blocks.

     Besides the machine-readable data, this file contains useful commentaries
     which contain human-readable information like image size, percentage of
     mapped data, etc.

     The 'version' attribute is the block map file format version in the
     'major.minor' format. The version major number is increased whenever an
     incompatible block map format change is made. The minor number changes
     in case of minor backward-compatible changes. -->

<bmap version="%s">
    <!-- Image size in bytes (%s) -->
    <ImageSize> %u </ImageSize>

    <!-- Size of a block in bytes -->
    <BlockSize> %u </BlockSize>

    <!-- Count of blocks in the image file -->
    <BlocksCount> %u </BlocksCount>

    <!-- The block map which consists of elements which may either be a
         range of blocks or a single block. The 'sha1' attribute (if present)
         is the SHA1 checksum of this blocks range. -->
    <BlockMap>
"""

class Error(Exception):
    """ A class for exceptions generated by the 'BmapCreate' module. We
    currently support only one type of exceptions, and we basically throw
    human-readable problem description in case of errors. """

    def __init__(self, strerror, errno = None):
        Exception.__init__(self, strerror)
        self.strerror = strerror
        self.errno = errno

    def __str__(self):
        return self.strerror

class BmapCreate:
    """ This class implements the bmap creation functionality. To generate a
    bmap for an image (which is supposedly a sparse file), you should first
    create an instance of 'BmapCreate' and provide:

    * full path or a file-like object of the image to create bmap for
    * full path or a file-like object to use for writing the results to

    Then you should invoke the 'generate()' method of this class. It will use
    the FIEMAP ioctl to generate the bmap. """

    def _open_image_file(self):
        """ Open the image file. """

        try:
            self._f_image = open(self._image_path, 'rb')
        except IOError as err:
            raise Error("cannot open image file '%s': %s" \
                        % (self._image_path, err), err.errno)

        self._f_image_needs_close = True

    def _open_bmap_file(self):
        """ Open the bmap file. """

        try:
            self._f_bmap = open(self._bmap_path, 'w+')
        except IOError as err:
            raise Error("cannot open bmap file '%s': %s" \
                        % (self._bmap_path, err), err.errno)

        self._f_bmap_needs_close = True

    def __init__(self, image, bmap):
        """ Initialize a class instance:
        * image - full path or a file-like object of the image to create bmap
                  for
        * bmap  - full path or a file-like object to use for writing the
                  resulting bmap to """

        self.bmap_image_size = None
        self.bmap_image_size_human = None
        self.bmap_block_size = None
        self.bmap_blocks_cnt = None
        self.bmap_mapped_cnt = None
        self.bmap_mapped_size = None
        self.bmap_mapped_size_human = None
        self.bmap_mapped_percent = None

        self._f_image_needs_close = False
        self._f_bmap_needs_close = False

        if hasattr(image, "read"):
            self._f_image = image
            self._image_path = image.name
        else:
            self._image_path = image
            self._open_image_file()

        if hasattr(bmap, "read"):
            self._f_bmap = bmap
            self._bmap_path = bmap.name
        else:
            self._bmap_path = bmap
            self._open_bmap_file()

        self.bmap_image_size = os.fstat(self._f_image.fileno()).st_size
        self.bmap_image_size_human = human_size(self.bmap_image_size)
        if self.bmap_image_size == 0:
            raise Error("cannot generate bmap for zero-sized image file '%s'" \
                        % self._image_path)

        try:
            self.bmap_block_size = get_block_size(self._f_image)
        except IOError as err:
            raise Error("cannot get block size for '%s': %s" \
                        % (self._image_path, err), err.errno)

        self.bmap_blocks_cnt = self.bmap_image_size + self.bmap_block_size - 1
        self.bmap_blocks_cnt /= self.bmap_block_size

        # Check if the FIEMAP ioctl is supported
        self._is_mapped(0)

    def _bmap_file_start(self):
        """ A helper function which generates the starting contents of the
        block map file: the header comment, image size, block size, etc. """

        xml = _BMAP_START_TEMPLATE \
               % (SUPPORTED_BMAP_VERSION,
                  self.bmap_image_size_human, self.bmap_image_size,
                  self.bmap_block_size, self.bmap_blocks_cnt)

        self._f_bmap.write(xml)

    def _is_mapped(self, block):
        """ A helper function which returns 'True' if block number 'block' of
        the image file is mapped and 'False' otherwise.

        This function uses the FIEMAP ioctl to detect whether 'block' is mapped
        to the disk. However, we do not use all the power of this ioctl: we
        call it for each and every block, while there is a possibility to call
        it once for a range of blocks, which is a lot faster when dealing with
        huge files. """

        # I know that the below cruft is not readable. To understand that, you
        # need to know the FIEMAP interface, which is documented in the
        # Documentation/filesystems/fiemap.txt file in the Linux kernel
        # sources. The ioctl is quite complex and python is not the best tool
        # for dealing with ioctls...

        # Prepare a 'struct fiemap' buffer which contains a single
        # 'struct fiemap_extent' element.
        struct_fiemap_format = "=QQLLLL"
        struct_size = struct.calcsize(struct_fiemap_format)
        buf = struct.pack(struct_fiemap_format,
                          block * self.bmap_block_size,
                          self.bmap_block_size, 0, 0, 1, 0)
        # sizeof(struct fiemap_extent) == 56
        buf += "\0"*56
        # Python strings are "immutable", meaning that python will pass a copy
        # of the string to the ioctl, unless we turn it into an array.
        buf = array.array('B', buf)

        try:
            ioctl(self._f_image, 0xC020660B, buf, 1)
        except IOError as err:
            error_msg = "the FIBMAP ioctl failed for '%s': %s" \
                        % (self._image_path, err)
            if err.errno == os.errno.EPERM or err.errno == os.errno.EACCES:
                # The FIEMAP ioctl was added in kernel version 2.6.28 in 2008
                error_msg += " (looks like your kernel does not support FIEMAP)"

            raise Error(error_msg, err.errno)

        res = struct.unpack(struct_fiemap_format, buf[:struct_size])
        # res[3] is the 'fm_mapped_extents' field of 'struct fiemap'. If it
        # contains zero, the block is not mapped, otherwise it is mapped.
        return bool(res[3])

    def _get_ranges(self):
        """ A helper function which generates ranges of mapped image file
        blocks. """

        iterator = xrange(self.bmap_blocks_cnt)
        for key, group in groupby(iterator, self._is_mapped):
            if key:
                # Find the first and the last elements of the group
                first = group.next()
                last = first
                for last in group:
                    pass
                yield first, last

    def _bmap_file_end(self):
        """ A helper function which generates the final parts of the block map
        file: the ending tags and the information about the amount of mapped
        blocks. """

        xml =  "    </BlockMap>\n\n"
        xml += "    <!-- Count of mapped blocks (%s or %.1f%% mapped) -->\n" \
               % (self.bmap_mapped_size_human, self.bmap_mapped_percent)
        xml += "    <MappedBlocksCount> %u </MappedBlocksCount>\n" \
               % self.bmap_mapped_cnt
        xml += "</bmap>\n"

        self._f_bmap.write(xml)

    def _calculate_sha1(self, first, last):
        """ A helper function which calculates SHA1 checksum for the range of
        blocks of the image file: from block 'first' to block 'last'. """

        start = first * self.bmap_block_size
        end = (last + 1) * self.bmap_block_size

        self._f_image.seek(start)
        hash_obj = hashlib.new("sha1")

        chunk_size = 1024*1024
        to_read = end - start
        read = 0

        while read < to_read:
            if read + chunk_size > to_read:
                chunk_size = to_read - read
            chunk = self._f_image.read(chunk_size)
            hash_obj.update(chunk)
            read += chunk_size

        return hash_obj.hexdigest()

    def generate(self, include_checksums = True):
        """ Generate bmap for the image file. If 'include_checksums' is 'True',
        also generate SHA1 checksums for block ranges. """

        # Save image file position in order to restore it at the end
        image_pos = self._f_image.tell()

        self._bmap_file_start()

        # Synchronize the image file before starting to generate its block map
        try:
            self._f_image.flush()
        except IOError as err:
            raise Error("cannot flush image file '%s': %s" \
                        % (self._image_path, err), err.errno)
        try:
            os.fsync(self._f_image.fileno()),
        except OSError as err:
            raise Error("cannot synchronize image file '%s': %s " \
                        % (self._image_path, err.strerror), err.errno)

        # Generate the block map and write it to the XML block map
        # file as we go.
        self.bmap_mapped_cnt = 0
        for first, last in self._get_ranges():
            self.bmap_mapped_cnt += last - first + 1
            if include_checksums:
                sha1 = self._calculate_sha1(first, last)
                sha1 = " sha1=\"%s\"" % sha1
            else:
                sha1 = ""

            if first != last:
                self._f_bmap.write("        <Range%s> %s-%s </Range>\n" \
                                   % (sha1, first, last))
            else:
                self._f_bmap.write("        <Range%s> %s </Range>\n" \
                                   % (sha1, first))

        self.bmap_mapped_size = self.bmap_mapped_cnt * self.bmap_block_size
        self.bmap_mapped_size_human = human_size(self.bmap_mapped_size)
        self.bmap_mapped_percent = self.bmap_mapped_cnt * 100.0
        self.bmap_mapped_percent /= self.bmap_blocks_cnt

        self._bmap_file_end()

        self._f_bmap.flush()

        self._f_image.seek(image_pos)

    def __del__(self):
        """ The class destructor which closes the opened files. """

        if self._f_image_needs_close:
            self._f_image.close()
        if self._f_bmap_needs_close:
            self._f_bmap.close()
