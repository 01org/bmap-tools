""" This module allows opening and reading various kind of files irrespectively
on whether the file is compressed or not. If it is compressed, this module will
decompress the contents on-the-fly. """

import os
import stat

# A list of supported compression types
SUPPORTED_COMPRESSION_TYPES = ('bz2', 'gz', 'tar.gz', 'tgz', 'tar.bz2')

class Error(Exception):
    """ A class for exceptions generated by this module. We currently support
    only one type of exceptions, and we basically throw human-readable problem
    description in case of errors. """
    pass

class TransRead:
    """ This class implement the transparent reading functionality. Instances
    of this class are file-like objects which you can read and seek only
    forward.
    """

    def _open_compressed_file(self):
        """ Detect file compression type and open it with the corresponding
        compression module, or just plain 'open() if the file is not
        compressed. """

        try:
            if self.filepath.endswith('.tar.gz') \
               or self.filepath.endswith('.tar.bz2') \
               or self.filepath.endswith('.tgz'):
                import tarfile

                tar = tarfile.open(self.filepath, 'r')
                # The tarball is supposed to contain only one single member
                members = tar.getnames()
                if len(members) > 1:
                    raise Error("tarball '%s' contains more than one file" \
                                % self.filepath)
                elif len(members) == 0:
                    raise Error("tarball '%s' is empty (no files)" \
                                % self.filepath)

                self._transfile_obj = tar.extractfile(members[0])
            elif self.filepath.endswith('.gz'):
                import gzip

                self._transfile_obj = gzip.GzipFile(self.filepath, 'rb')
            elif self.filepath.endswith('.bz2'):
                import bz2

                self._transfile_obj = bz2.BZ2File(self.filepath, 'rb')
            else:
                self.is_compressed = False
                self._transfile_obj = self._file_obj
                self.size = os.fstat(self._file_obj.fileno()).st_size
                self._file_obj = None
        except IOError as err:
            raise Error("cannot open file '%s': %s" % (self.filepath, err))

    def close(self):
        """ Close the file-like object. """

        self.__del__()

    def __init__(self, filepath):
        """ Class constructor. The 'filepath' argument is the full path to the
        file to read transparently. """

        self.filepath = filepath
        self.size = None
        self.is_compressed = True

        self._transfile_obj = None

        try:
            self._file_obj = open(filepath, "rb")
        except IOError as err:
            raise Error("cannot open file '%s': %s" % (filepath, err))

        st_mode = os.fstat(self._file_obj.fileno()).st_mode
        if not stat.S_ISREG(st_mode):
            raise Error("file '%s' is not a regular file" % self.filepath)

        self._open_compressed_file()

    def __del__(self):
        """ The class destructor which closes opened files. """

        if self._transfile_obj:
            self._transfile_obj.close()
        if self._file_obj:
            self._file_obj.close()

    def __getattr__(self, name):
        """ Called for all attributes that do not exist in the 'TransRead'
        class. We are pretending to be file-like objects, so we just return the
        attributes of the '_transfile_obj' file-like object. """

        return getattr(self._transfile_obj, name)
